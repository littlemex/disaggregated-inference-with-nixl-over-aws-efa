{
  "name": "Low-Level: NIXLBench {{ backend }} - {{ message_size_human }} - {{ scheme }} t={{ num_threads }}",
  "description": "NIXL VRAM-to-VRAM transfer measurement: backend={{ backend }}, size={{ message_size }}, scheme={{ scheme }}, threads={{ num_threads }}",
  "variables": {
    "OUTPUT_DIR": "/tmp/low-level-results",
    "OUTPUT_FILE": "/tmp/low-level-results/{{ pattern_id }}.json",
    "ETCD_ENDPOINT": "http://{% raw %}{{NODE1_PRIVATE}}{% endraw %}:{{ infrastructure.etcd_port }}",
    "NIXL_PATH": "{{ infrastructure.nixl_path }}",
    "NODE1_PRIVATE": "{% raw %}{{NODE1_PRIVATE}}{% endraw %}"
  },
  "tasks": [
    {
      "id": "01-create-output-dir",
      "name": "Create Output Directory",
      "skip_if": "test -d /tmp/low-level-results",
      "commands": [
        "mkdir -p /tmp/low-level-results",
        "echo '[OK] Output directory created'"
      ]
    },
    {
      "id": "02-start-etcd",
      "name": "Start ETCD Server",
      "description": "Start ETCD server in Docker container (idempotent)",
      "skip_if": "docker ps --filter name=etcd-nixlbench --format '{% raw %}{{.Names}}{% endraw %}' | grep -q etcd-nixlbench",
      "commands": [
        "docker rm -f etcd-nixlbench 2>/dev/null || true",
        "docker run -d --name etcd-nixlbench --network host quay.io/coreos/etcd:{{ infrastructure.etcd_version }} /usr/local/bin/etcd --listen-client-urls=http://0.0.0.0:{{ infrastructure.etcd_port }} --advertise-client-urls=http://0.0.0.0:{{ infrastructure.etcd_port }}",
        "sleep 3",
        "curl -s http://localhost:{{ infrastructure.etcd_port }}/health | grep -q 'true' && echo '[OK] ETCD server running' || { echo '[ERROR] ETCD failed to start'; exit 1; }"
      ]
    },
    {
      "id": "03-verify-nixlbench",
      "name": "Verify NIXLBench Binary",
      "description": "Check nixlbench binary exists",
      "commands": [
        "if command -v nixlbench >/dev/null 2>&1; then echo '[OK] nixlbench found in PATH'; elif [ -f {% raw %}{{NIXL_PATH}}{% endraw %}/benchmark/nixlbench/nixlbench ]; then echo '[OK] nixlbench found at {% raw %}{{NIXL_PATH}}{% endraw %}/benchmark/nixlbench/nixlbench'; else echo '[ERROR] nixlbench not found'; exit 1; fi"
      ]
    },
    {
      "id": "04-verify-gpu",
      "name": "Verify GPU Access",
      "description": "Ensure GPU is available for VRAM allocation",
      "commands": [
        "nvidia-smi --query-gpu=index,name,memory.total,memory.free --format=csv,noheader",
        "echo '[OK] GPU available'"
      ]
    },
    {
      "id": "06-run-nixlbench",
      "name": "Run NIXLBench ({{ backend }}, {{ message_size_human }}, {{ scheme }})",
      "description": "Execute NIXLBench measurement",
      "commands": [
        "NIXLBENCH_BIN=$(command -v nixlbench 2>/dev/null || echo '{% raw %}{{NIXL_PATH}}{% endraw %}/benchmark/nixlbench/nixlbench')",
{% if backend == 'Libfabric' %}
        "export FI_PROVIDER=efa",
        "export FI_EFA_USE_DEVICE_RDMA=1",
        "export FI_EFA_FORK_SAFE=1",
{% endif %}
        "echo '[INFO] Running NIXLBench: backend={{ backend }}, size={{ message_size }}, scheme={{ scheme }}, threads={{ num_threads }}'",
        "RAW_OUTPUT=$(timeout 600 $NIXLBENCH_BIN --etcd_endpoints {% raw %}{{ETCD_ENDPOINT}}{% endraw %} --backend {{ backend }} --initiator_seg_type {{ initiator_seg_type }} --target_seg_type {{ target_seg_type }} --message_size {{ message_size }} --num_threads {{ num_threads }} --scheme {{ scheme }} --iterations {{ iterations }} 2>&1) || { echo '[WARNING] NIXLBench timed out or failed (exit=$?)'; }",
        "echo \"$RAW_OUTPUT\"",
        "echo \"$RAW_OUTPUT\" > {% raw %}{{OUTPUT_DIR}}{% endraw %}/{{ pattern_id }}_raw.log",
        "python3 -c \"",
        "import json, re",
        "with open('{% raw %}{{OUTPUT_DIR}}{% endraw %}/{{ pattern_id }}_raw.log') as f:",
        "    raw = f.read()",
        "result = {",
        "    'tool': 'nixlbench',",
        "    'pattern_id': '{{ pattern_id }}',",
        "    'backend': '{{ backend }}',",
        "    'initiator_seg_type': '{{ initiator_seg_type }}',",
        "    'target_seg_type': '{{ target_seg_type }}',",
        "    'message_size': {{ message_size }},",
        "    'message_size_human': '{{ message_size_human }}',",
        "    'num_threads': {{ num_threads }},",
        "    'scheme': '{{ scheme }}',",
        "    'iterations': {{ iterations }},",
        "    'raw_output': raw,",
        "}",
        "lines = raw.strip().split('\\n')",
        "for line in lines:",
        "    if 'p50' in line.lower():",
        "        m = re.search(r':\\s*([\\d.]+)', line)",
        "        if m: result['latency_p50_us'] = float(m.group(1))",
        "    if 'p95' in line.lower():",
        "        m = re.search(r':\\s*([\\d.]+)', line)",
        "        if m: result['latency_p95_us'] = float(m.group(1))",
        "    if 'p99' in line.lower():",
        "        m = re.search(r':\\s*([\\d.]+)', line)",
        "        if m: result['latency_p99_us'] = float(m.group(1))",
        "    if 'bandwidth' in line.lower() or 'throughput' in line.lower():",
        "        m = re.search(r'([\\d.]+)\\s*(GB/s|MB/s)', line)",
        "        if m:",
        "            bw = float(m.group(1))",
        "            if m.group(2) == 'MB/s': bw /= 1000",
        "            result['bandwidth_gbps'] = bw",
        "if 'latency_p50_us' in result:",
        "    transfer_ms = result['latency_p50_us'] / 1000",
        "    result['transfer_time_ms'] = transfer_ms",
        "with open('{% raw %}{{OUTPUT_FILE}}{% endraw %}', 'w') as f:",
        "    json.dump(result, f, indent=2)",
        "print('[OK] Results parsed and saved')",
        "\""
      ]
    },
    {
      "id": "07-collect-results",
      "name": "Collect Results",
      "description": "Display measurement results",
      "commands": [
        "echo '--- NIXLBench Results ---'",
        "cat {% raw %}{{OUTPUT_FILE}}{% endraw %} 2>/dev/null | python3 -m json.tool || echo '[INFO] Results file not found'",
        "echo '--- End Results ---'"
      ]
    }
  ]
}
