{
  "name": "Phase {{ phase }}: {{ backend|upper }} Producer - {{ prompt_tokens }} tokens - c={{ concurrency }}",
  "description": "{{ backend|upper }} Disaggregated Producer, {{ prompt_tokens }} tokens, c={{ concurrency }}, Prefix Cache {{ 'ON' if prefix_cache else 'OFF' }}",
  "variables": {
    "VENV_PATH": "{{ infrastructure.venv_path }}",
    "MODEL": "{{ infrastructure.model }}",
    "PORT": "8100",
    "PROXY_PORT": "8000",
    "CONSUMER_PORT": "8200",
    "BENCHMARK_SCRIPT": "/tmp/benchmark_common.py",
    "PROXY_SCRIPT": "/tmp/disagg_proxy_server.py",
    "OUTPUT_FILE": "/tmp/results/{{ pattern_id }}.json",
    "LOG_FILE": "/tmp/vllm_producer_{{ backend }}_{{ pattern_id }}.log",
    "PID_FILE": "/tmp/vllm_producer_{{ backend }}_{{ pattern_id }}.pid",
    "PROXY_LOG_FILE": "/tmp/proxy_{{ backend }}_{{ pattern_id }}.log",
    "PROXY_PID_FILE": "/tmp/proxy_{{ backend }}_{{ pattern_id }}.pid",
    "PROMPT_TOKENS": "{{ prompt_tokens }}",
    "MAX_TOKENS": "{{ max_tokens }}",
    "CONCURRENCY": "{{ concurrency }}",
    "WARMUP_ITERATIONS": "{{ warmup_iterations }}",
    "NUM_ITERATIONS": "{{ measurement_iterations }}",
    "GPU_MEMORY_UTIL": "{{ gpu_memory_utilization }}",
    "MAX_BATCHED_TOKENS": "{{ max_num_batched_tokens }}",
    "MAX_MODEL_LEN": "{{ max_model_len }}",
{% if infrastructure.tp_size is defined and infrastructure.tp_size > 1 %}
    "TP_SIZE": "{{ infrastructure.tp_size }}",
{% endif %}
    "PHASE": "{{ phase }}"
  },
  "tasks": [
    {
      "id": "01-verify-scripts",
      "name": "Verify Scripts",
      "description": "Verify benchmark and proxy scripts exist",
      "commands": [
        "if [ ! -f {{"{{"}}BENCHMARK_SCRIPT{{"}}"}} ]; then echo '[ERROR] Benchmark script not found: {{"{{"}}BENCHMARK_SCRIPT{{"}}"}}'; exit 1; fi",
        "if [ ! -f {{"{{"}}PROXY_SCRIPT{{"}}"}} ]; then echo '[ERROR] Proxy script not found: {{"{{"}}PROXY_SCRIPT{{"}}"}}'; exit 1; fi",
        "echo '[OK] All scripts found'"
      ]
    },
    {
      "id": "02-cleanup-gpu",
      "name": "Cleanup GPU Memory",
      "description": "Terminate existing vLLM processes and ensure GPU memory is released",
      "commands": [
        "echo '[INFO] Cleaning up GPU memory...'",
        "pgrep -f 'vllm\\.entrypoints' 2>/dev/null | xargs -r sudo kill -9 2>/dev/null || true",
        "pgrep -f 'ray::' 2>/dev/null | xargs -r sudo kill -9 2>/dev/null || true",
        "pgrep -f 'disagg_proxy' 2>/dev/null | xargs -r sudo kill -9 2>/dev/null || true",
        "pgrep -f 'python.*vllm\\|python.*disagg_proxy' 2>/dev/null | xargs -r sudo kill -9 2>/dev/null || true",
        "sleep 5",
        "nvidia-smi --query-compute-apps=pid --format=csv,noheader 2>/dev/null | while read pid; do [ -n \"$pid\" ] && sudo kill -9 $pid 2>/dev/null || true; done",
        "echo '[INFO] Waiting for GPU memory to be released (max 60 seconds)...'",
        "for i in $(seq 1 12); do MAX_MEM=$(nvidia-smi --query-gpu=memory.used --format=csv,noheader,nounits 2>/dev/null | sort -rn | head -1); if [ -z \"$MAX_MEM\" ] || [ \"$MAX_MEM\" -lt 1000 ]; then echo '[OK] GPU memory released'; break; fi; [ $((i % 3)) -eq 0 ] && echo '[INFO] Waiting... GPU memory: '$MAX_MEM' MiB ('$i'/12)'; sleep 5; done",
        "nvidia-smi --query-gpu=index,memory.used --format=csv,noheader || true"
      ]
    },
    {
      "id": "03-start-producer",
      "name": "Start vLLM Producer ({{ backend|upper }}, {{ 'Prefix Cache ON' if prefix_cache else 'Prefix Cache OFF' }})",
      "description": "Start Producer ({{ backend|upper }}, max_model_len={{ max_model_len }})",
      "skip_if": "pgrep -f 'vllm.entrypoints.openai.api_server.*kv_producer.*--max-model-len {{"{{"}}MAX_MODEL_LEN{{"}}"}}' > /dev/null && curl -s http://localhost:{{"{{"}}PORT{{"}}"}}/health | grep -q ok",
      "commands": [
        "if [ -z \"$NODE1_PRIVATE\" ]; then echo '[ERROR] NODE1_PRIVATE not set'; exit 1; fi",
{% if infrastructure.tp_size is defined and infrastructure.tp_size > 1 %}
        "export NCCL_DEBUG=WARN",
        "export NCCL_IB_DISABLE=0",
{% endif %}
{% if backend == 'efa' %}
        "export NIXL_BACKEND=LIBFABRIC",
        "export FI_PROVIDER=efa",
        "export FI_EFA_FORK_SAFE=1",
        "export FI_LOG_LEVEL=warn",
{% elif backend == 'tcp' %}
        "export NIXL_BACKEND=TCP",
{% else %}
        "export NIXL_BACKEND=UCX",
{% endif %}
        "export NIXL_LOG_LEVEL=INFO",
        "export VLLM_NIXL_SIDE_CHANNEL_HOST=$NODE1_PRIVATE",
        "export VLLM_ALLOW_LONG_MAX_MODEL_LEN=1",
        "nohup {{"{{"}}VENV_PATH{{"}}"}}/bin/python3 -m vllm.entrypoints.openai.api_server --model {{"{{"}}MODEL{{"}}"}} --disable-log-requests --trust-remote-code --port {{"{{"}}PORT{{"}}"}} {% if infrastructure.tp_size is defined and infrastructure.tp_size > 1 %}--tensor-parallel-size {{ tp_per_node }} {% endif %}--gpu-memory-utilization {{"{{"}}GPU_MEMORY_UTIL{{"}}"}} --max-num-batched-tokens {{"{{"}}MAX_BATCHED_TOKENS{{"}}"}} --enable-chunked-prefill --enforce-eager --max-model-len {{"{{"}}MAX_MODEL_LEN{{"}}"}} {{ '--enable-prefix-caching' if prefix_cache else '--no-enable-prefix-caching' }} --kv-transfer-config '{\"kv_connector\":\"NixlConnector\",\"kv_role\":\"kv_producer\",\"kv_rank\":0,\"kv_parallel_size\":2,\"kv_buffer_device\":\"{% if backend == 'tcp' %}cpu{% else %}cuda{% endif %}\",\"kv_buffer_size\":{{ kv_buffer_size }},\"kv_connector_extra_config\":{\"backends\":[\"{% if backend == 'efa' %}LIBFABRIC{% elif backend == 'tcp' %}TCP{% else %}UCX{% endif %}\"]{% if enable_cross_layers_blocks %},\"enable_cross_layers_blocks\":\"True\"{% endif %}}}' > {{"{{"}}LOG_FILE{{"}}"}} 2>&1 &",
        "echo $! > {{"{{"}}PID_FILE{{"}}"}}",
        "echo '[OK] {{ backend|upper }} Producer started ({{ 'Prefix Cache ON' if prefix_cache else 'Prefix Cache OFF' }})'"
      ]
    },
    {
      "id": "04-wait-initialization",
      "name": "Wait for Producer Initialization",
      "description": "Wait for model initialization",
      "commands": [
        "echo '[INFO] Waiting {{ init_wait_seconds }} seconds for initialization...'",
        "sleep {{ init_wait_seconds }}"
      ]
    },
    {
      "id": "05-health-check",
      "name": "Producer Health Check (OOM Detection)",
      "description": "Verify Producer server is ready with OOM/error early detection",
      "commands": [
        "HEALTH_OK=false; OOM_DETECTED=false; ERROR_DETECTED=false; HEALTH_TIMEOUT={{ health_check_timeout | default(300) }}; for i in $(seq 1 $HEALTH_TIMEOUT); do HTTP_CODE=$(curl -s -o /dev/null -w '%{http_code}' http://localhost:{{"{{"}}PORT{{"}}"}}/health 2>/dev/null || echo '000'); if [ \"$HTTP_CODE\" = \"200\" ]; then echo \"[OK] Producer server ready (took $i seconds)\"; HEALTH_OK=true; break; fi; if [ $((i % 10)) -eq 0 ]; then if grep -qE 'torch\\.OutOfMemoryError|CUDA out of memory|torch\\.cuda\\.OutOfMemoryError|Cannot allocate memory|KV cache is needed.*larger than.*available' {{"{{"}}LOG_FILE{{"}}"}} 2>/dev/null; then echo '[ERROR] OOM detected in Producer logs'; OOM_DETECTED=true; break; fi; if grep -qE 'ValueError.*max seq len|RuntimeError.*CUDA|Traceback \\(most recent call last\\)' {{"{{"}}LOG_FILE{{"}}"}} 2>/dev/null; then echo '[ERROR] Producer startup error detected'; ERROR_DETECTED=true; break; fi; fi; if [ $((i % 30)) -eq 0 ]; then LAST_LOG=$(tail -1 {{"{{"}}LOG_FILE{{"}}"}} 2>/dev/null || echo 'no log'); echo \"[INFO] Waiting... ($i/$HEALTH_TIMEOUT) - Last log: $LAST_LOG\"; fi; sleep 1; done; if [ \"$OOM_DETECTED\" = \"true\" ]; then echo '[FATAL] VRAM OOM - this pattern requires more GPU memory than available'; echo '--- Last 30 lines of log ---'; tail -30 {{"{{"}}LOG_FILE{{"}}"}};  echo '--- End of log ---'; false; elif [ \"$ERROR_DETECTED\" = \"true\" ]; then echo '[FATAL] Producer startup error'; echo '--- Last 30 lines of log ---'; tail -30 {{"{{"}}LOG_FILE{{"}}"}};  echo '--- End of log ---'; false; elif [ \"$HEALTH_OK\" = \"false\" ]; then echo \"[ERROR] Producer health check timeout ($HEALTH_TIMEOUT seconds)\"; echo '--- Last 50 lines of log ---'; tail -50 {{"{{"}}LOG_FILE{{"}}"}};  echo '--- End of log ---'; false; fi"
      ]
    },
    {
      "id": "05b-verify-nixl-backend",
      "name": "Verify NIXL Backend",
      "description": "Verify NIXL backend initialization from logs",
      "commands": [
        "echo '[INFO] Verifying NIXL backend initialization...'",
        "sleep 10",
        "grep -i 'nixl\\|backend\\|LIBFABRIC' {{"{{"}}LOG_FILE{{"}}"}} | tail -20 || echo '[WARNING] No NIXL backend info found in logs'",
        "echo '[OK] Backend verification complete'"
      ]
    },
    {
      "id": "06-start-proxy",
      "name": "Start Disaggregated Proxy Server",
      "description": "Start Proxy server (Prefill -> Decode request routing)",
      "skip_if": "curl -s http://localhost:{{"{{"}}PROXY_PORT{{"}}"}}/health | grep -q healthy",
      "commands": [
        "if [ -z \"$NODE1_PRIVATE\" ] || [ -z \"$NODE2_PRIVATE\" ]; then echo '[ERROR] NODE1_PRIVATE and NODE2_PRIVATE must be set'; exit 1; fi",
        "nohup {{"{{"}}VENV_PATH{{"}}"}}/bin/python3 {{"{{"}}PROXY_SCRIPT{{"}}"}} --prefill-url http://$NODE1_PRIVATE:{{"{{"}}PORT{{"}}"}} --decode-url http://$NODE2_PRIVATE:{{"{{"}}CONSUMER_PORT{{"}}"}} --port {{"{{"}}PROXY_PORT{{"}}"}} > {{"{{"}}PROXY_LOG_FILE{{"}}"}} 2>&1 &",
        "echo $! > {{"{{"}}PROXY_PID_FILE{{"}}"}}",
        "echo '[OK] Proxy server started on port {{"{{"}}PROXY_PORT{{"}}"}}'",
        "sleep 5"
      ]
    },
    {
      "id": "07-proxy-health-check",
      "name": "Proxy Health Check",
      "description": "Verify Proxy server is ready",
      "commands": [
        "HEALTH_OK=false; for i in $(seq 1 30); do HTTP_CODE=$(curl -s -o /dev/null -w '%{http_code}' http://localhost:{{"{{"}}PROXY_PORT{{"}}"}}/health 2>/dev/null || echo '000'); if [ \"$HTTP_CODE\" = \"200\" ]; then echo '[OK] Proxy server ready'; HEALTH_OK=true; break; fi; [ $((i % 10)) -eq 0 ] && echo '[INFO] Waiting for proxy... ('$i'/30)'; sleep 1; done; if [ \"$HEALTH_OK\" = \"false\" ]; then echo '[ERROR] Proxy health check timeout'; false; fi"
      ]
    },
    {
      "id": "08-run-benchmark",
      "name": "Run Benchmark ({{ backend|upper }}, {{ prompt_tokens }} tokens, c={{ concurrency }})",
      "description": "Run benchmark (Proxy, warmup={{ warmup_iterations }}, measurement={{ measurement_iterations }}, c={{ concurrency }})",
      "skip_if": "test -s {{"{{"}}OUTPUT_FILE{{"}}"}} && python3 -c \"import json; json.load(open('{{"{{"}}OUTPUT_FILE{{"}}"}}'))\" 2>/dev/null && echo '[SKIP] Benchmark already completed: {{"{{"}}OUTPUT_FILE{{"}}"}}'",
      "commands": [
        "sudo mkdir -p /tmp/results && sudo chown ubuntu:ubuntu /tmp/results",
        "sudo -u ubuntu env MLFLOW_EXPERIMENT_TIMESTAMP=\"${MLFLOW_EXPERIMENT_TIMESTAMP:-}\" python3 {{"{{"}}BENCHMARK_SCRIPT{{"}}"}} --measurement-type online --url http://localhost:{{"{{"}}PROXY_PORT{{"}}"}} --model {{"{{"}}MODEL{{"}}"}} --mode disaggregated --backend {{ backend }} --prompt-tokens {{"{{"}}PROMPT_TOKENS{{"}}"}} --max-tokens {{"{{"}}MAX_TOKENS{{"}}"}} --warmup-iterations {{"{{"}}WARMUP_ITERATIONS{{"}}"}} --num-iterations {{"{{"}}NUM_ITERATIONS{{"}}"}} --concurrency {{"{{"}}CONCURRENCY{{"}}"}} --prefix-cache {{ 'enabled' if prefix_cache else 'disabled' }} --output {{"{{"}}OUTPUT_FILE{{"}}"}} --mlflow-tracking-uri arn:aws:sagemaker:us-east-1:776010787911:mlflow-tracking-server/nixl-efa-mlflow2 --mlflow-experiment-name nixl-efa-phase1 --phase {{"{{"}}PHASE{{"}}"}} --layer '{{ layer_name }}' --priority '{{ layer_priority }}' --tags 'phase={{ phase }}{% if infrastructure.tp_size is defined %},tp_size={{ infrastructure.tp_size }}{% endif %},instance={{ infrastructure.instance_type }},backend={{ backend }}' --mlflow-run-name {{ pattern_id }}-$(date +%Y%m%d-%H%M%S)",
        "echo '[OK] Benchmark complete: {{"{{"}}OUTPUT_FILE{{"}}"}}'"
      ]
    },
    {
      "id": "09-collect-results",
      "name": "Collect Results",
      "description": "Display results JSON",
      "commands": [
        "echo '--- Results Summary ---'",
        "cat {{"{{"}}OUTPUT_FILE{{"}}"}} | head -30 || echo '[INFO] Results file not found'",
        "echo '--- End Results ---'"
      ]
    }
  ]
}
